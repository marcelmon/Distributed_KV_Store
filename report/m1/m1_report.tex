\documentclass[12pt]{article}

\usepackage{multicol}
\usepackage[margin=0.75in]{geometry}
\usepackage{titlesec}
\usepackage{amsmath}
\usepackage[
backend=biber,
style=ieee,
sorting=ynt
]{biblatex}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{float}

% \pagestyle{fancy}
%\fancyhf{}

\title{ECE419 M1 Report}
\date{28 January 2018}
\author{Thomas Kingsford\\Marcel Mongeon\\Zhihao Sheng}

%\titleformat{\section}{\normalfont\scshape}{\thesection}{1em}{}
%\titlespacing*{\section}{0pt}{10pt}{0pt}

%\setlength{\parindent}{0pt}
%\setlength{\parskip}{0cm}
%\renewcommand{\baselinestretch}{0.5}
%\setlist{noitemsep} % {nosep, noitemsep}

\begin{document}
\begin{multicols}{2}
\maketitle

\section{Design and Decisions}

\paragraph{Architecture} Refer to Figure \ref{arch} in the Appendices for an architecture diagram.

\paragraph{KVClient} The KVClient class handles client side interface. It creats a user interface which contains following operations:

\begin{enumerate}
    \item connect <hostname> <port>: establishing a connection to the host server with the port number.
    \item put <key> <value>: sending the key-value pair to the server which will store the pair.
    \item get <key>: getting the key-value pair with the key from the server.
    \item logLevel: setting the log level. The default level is OFF.
    \item disconnect: disconnecting from the current server.
    \item quit: quiting the application after disconnecting from the server.
\rend{enumerate}

\paragraph{KVStore} The KVStore class handles the messages from the KVClient and passes them to the CommMod.

\paragraph{KVServer} The KVServer class handles server side interface. It gets the KVMessage from KVClient through the CommMod and does the put or get request, then it will give the response to the KVClient through the CommMode.

\paragraph{CommMod} The CommMod class handles client and server communications. The server registers as a listener and receives KVMessages by way of a callback. The server must respond to each received KVMessage with a response message. Clients Connect() then send messages via SendMessage(), which returns a KVMessage response or else times out if the server fails to respond quickly enough.

\paragraph{TLVMessage} The TLVMessage is an implementation of the KVMessage interface. it implements a modification of tag-length-value encoding. It (un)marshals a KV message as a sequence of bytes in which:

\begin{enumerate}
\item The first byte is the ordinal value of the StatusType enum, referred to as a 'tag'.
\item The second byte is the length of the key $L_K \in [0, 255]$. This protocol imposes an upper limit on key size of 255 bytes.
\item For messages containing a value (the existence of a value is fully determined by the tag), the third byte is the length of the value $L_V \in [0, 255]$. This protocol imposes an upper limit on key size of 255 bytes. This could be trivially extended - for instance, the use of four bytes would give a maximum length of $2^32-1\approx 1 \text{ billion bytes}$
\item The following $L_K$ bytes are the key.
\item If there is a value, the following $L_V$ bytes are the value.
\end{enumerate}

\paragraph{LRUCache}

\paragraph{LFUCache}

\paragraph{FIFOCache}

\paragraph{LockManager}

\paragraph{FilePerKeyKVDB}


\section{Performance Evaluation}


\section{Test Cases}

\subsection{CacheTests}

\subsection{CommModTests}

\subsection{ConnectionTest}

\subsection{InteractionTest}

\subsection{KVDBTests}

\subsection{LockManagerTest}

\subsection{SocketTest}

\subsection{StoreServerTests}

\subsection{TLVMessageTest}

\end{multicols}

\newpage

\section{Appendices}

\begin{figure}[H]
\centering
\includegraphics[scale=0.50]{architecture}
\caption{Architecture Diagram}
\label{arch}
\end{figure}
\end{document}

